<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>TypeScript类型挑战 - Cirplan</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="cirplan"><meta name=description content="typescript type challenges"><meta name=keywords content="typescript,type,challenges"><link rel=canonical href=https://cirplan.me/post/2022/10-11-ts-types-challenges/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link href=/sass/main.min.4325dd250c3d3e29d579a819f16fd876adbc5a03b3a1b32d2eefe0a067e8f219.css rel=stylesheet><meta property="og:title" content="TypeScript类型挑战"><meta property="og:description" content="typescript type challenges"><meta property="og:type" content="article"><meta property="og:url" content="https://cirplan.me/post/2022/10-11-ts-types-challenges/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-11T10:32:51+08:00"><meta property="article:modified_time" content="2022-10-11T10:32:51+08:00"><meta itemprop=name content="TypeScript类型挑战"><meta itemprop=description content="typescript type challenges"><meta itemprop=datePublished content="2022-10-11T10:32:51+08:00"><meta itemprop=dateModified content="2022-10-11T10:32:51+08:00"><meta itemprop=wordCount content="3401"><meta itemprop=keywords content="typescript,type,challenges,"><meta name=twitter:card content="summary"><meta name=twitter:title content="TypeScript类型挑战"><meta name=twitter:description content="typescript type challenges"></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Cirplan</a></div><div class=mobile-navbar-icon id=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>主页</li></a><a href=/post/><li class=mobile-menu-item>归档</li></a><a href=/tags/><li class=mobile-menu-item>标签</li></a><a href=/categories/><li class=mobile-menu-item>分类</li></a><a href=/about/><li class=mobile-menu-item>关于</li></a><a href=https://github.com/cirplan><li class=mobile-menu-item>Github</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Cirplan</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>主页</a></li><li class=menu-item><a class=menu-item-link href=/post/>归档</a></li><li class=menu-item><a class=menu-item-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-item-link href=/about/>关于</a></li><li class=menu-item><a class=menu-item-link href=https://github.com/cirplan>Github</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>TypeScript类型挑战</h1><div class=post-meta><span class=post-time>2022-10-11</span><div class=post-category><a href=/categories/typescript/>TypeScript</a></div><span class=more-meta>约 3401 字</span>
<span class=more-meta>预计阅读 7 分钟</span></div></header><div class=post-outdated><div class=hint><p>【注意】最后更新于 <span class=timeago datetime=2022-10-11T10:32:51 title=2022-10-11>2022-10-11, </span>，文中内容可能已过时，请谨慎使用。</p></div></div><div class=post-content><ul><li><a href=#%E5%89%8D%E8%A8%80>前言</a></li><li><a href=#%E5%87%86%E5%A4%87>准备</a><ul><li><a href=#>&</a></li><li><a href=#-1>|</a></li><li><a href=#keyof>Keyof</a></li><li><a href=#extends>extends</a></li><li><a href=#infer>infer</a></li></ul></li><li><a href=#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98>常见问题</a><ul><li><a href=#t-extends-x-vs-t-extends-x><code>[T] extends [X]</code> vs <code>T extends X</code></a></li><li><a href=#k-extends-k><code>K extends K</code></a></li><li><a href=#object-vs-object-vs-><code>Object</code> vs <code>object</code> vs <code>{}</code></a></li></ul></li><li><a href=#%E6%9C%80%E5%90%8E>最后</a></li><li><a href=#%E5%8F%82%E8%80%83>参考</a></li></ul><h2 id=前言>前言</h2><p>在上一篇文章，初步介绍了 <code>TS</code> 的内置工具类型，让我们对 <code>TS</code> 的类型转换有了初步的认识。接下来为了加深我们的理解，我们动手进行一系列的挑战。</p><p>这个挑战就是 <a href=https://github.com/type-challenges/type-challenges>type-challenges</a>，<a href=https://antfu.me/>antfu</a> 大佬创建的。再次膜拜顶级大佬。</p><p>可以看到该挑战区分了 <code>easy</code>、<code>medium</code>、<code>hard</code>、<code>extreme</code> 四大难度。点击进具体的题目，通过 <code>Take a Challenge</code> 进行作答，每一题会有对应的单元测试，测试通过代表你的解答是可以的。如果没有思路也没关系，可以通过 <code>Check out Solutions</code> 查看别人的思路。最后你有好的idea，可以 <code>Share your Solutions</code>，和大家一起讨论分享。</p><h2 id=准备>准备</h2><p>在开始挑战之前，你或许需要了解一些常见的类型操作符。</p><h3 id=8><a href=https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types>&</a></h3><p>交叉类型，把多个类型合并为一个类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>interface</span> <span class=nx>Colorful</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>color</span>: <span class=kt>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>interface</span> <span class=nx>Circle</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>radius</span>: <span class=kt>number</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>ColorfulCircle</span> <span class=o>=</span> <span class=nx>Colorful</span> <span class=o>&amp;</span> <span class=nx>Circle</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// type ColorfulCircle = {
</span></span></span><span class=line><span class=cl><span class=c1>//   color: string;
</span></span></span><span class=line><span class=cl><span class=c1>//   radius: number;
</span></span></span><span class=line><span class=cl><span class=c1>// }
</span></span></span></code></pre></td></tr></table></div></div><h3 id=9><a href=https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types>|</a></h3><p>联合类型，表示或的关系。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kd>function</span> <span class=nx>printId</span><span class=p>(</span><span class=nx>id</span>: <span class=kt>number</span> <span class=o>|</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Your ID is: &#34;</span> <span class=o>+</span> <span class=nx>id</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>printId</span><span class=p>(</span><span class=mi>101</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>printId</span><span class=p>(</span><span class=s2>&#34;202&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>printId</span><span class=p>({</span> <span class=nx>myID</span>: <span class=kt>22342</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=c1>// Argument of type &#39;{ myID: number; }&#39; is not assignable to parameter of type &#39;string | number&#39;.
</span></span></span></code></pre></td></tr></table></div></div><h3 id=keyof3><a href=https://www.typescriptlang.org/docs/handbook/2/keyof-types.html>Keyof</a></h3><p>对于对象类型，根据其 <code>keys</code> 返回一个字符串或数字的字面量联合类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>Point</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>x</span>: <span class=kt>number</span><span class=p>;</span> <span class=nx>y</span>: <span class=kt>number</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>P</span> <span class=o>=</span> <span class=k>keyof</span> <span class=nx>Point</span><span class=p>;</span> <span class=c1>// &#39;x&#39; | &#39;y&#39;
</span></span></span></code></pre></td></tr></table></div></div><p>如果类型包含 <code>字符串</code> 或 <code>数字</code> 索引，<code>keyof</code> 则直接返回其类型。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>Arrayish</span> <span class=o>=</span> <span class=p>{</span> <span class=p>[</span><span class=nx>n</span>: <span class=kt>number</span><span class=p>]</span><span class=o>:</span> <span class=kt>unknown</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>A</span> <span class=o>=</span> <span class=k>keyof</span> <span class=nx>Arrayish</span><span class=p>;</span> <span class=c1>// type A = number
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>Mapish</span> <span class=o>=</span> <span class=p>{</span> <span class=p>[</span><span class=nx>k</span>: <span class=kt>string</span><span class=p>]</span><span class=o>:</span> <span class=kr>boolean</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>M</span> <span class=o>=</span> <span class=k>keyof</span> <span class=nx>Mapish</span><span class=p>;</span> <span class=c1>// type M = string | number
</span></span></span></code></pre></td></tr></table></div></div><p><code>M</code> 的结果是 <code>string | number</code> 是因为 js 的对象索引都是转换成字符串的。所以 <code>obj[0]</code> 等同于 <code>obj["0"]</code>。</p><h3 id=extends4><a href=https://www.typescriptlang.org/docs/handbook/2/conditional-types.html>extends</a></h3><p>有条件的类型，其语法：</p><pre><code>T extends U ? X : Y
</code></pre><p>意思是若 <code>T</code> 能够赋值给 <code>U</code>，那么类型是 <code>X</code>，否则为 <code>Y</code>。</p><p>让我们回顾下<a href=https://www.typescriptlang.org/docs/handbook/type-compatibility.html#any-unknown-object-void-undefined-null-and-never-assignability>类型的分配</a>规则。</p><p><img src=/post/2022/images/1011ts/type-assignment.png alt="type assignability"></p><p>行代表赋值的类型，列表示被赋值的类型。就像 <code>any</code> 能够分配给 <code>unknow</code>、<code>object</code>、<code>void</code>、<code>undefined</code>、<code>null</code> 类型，但 <code>never</code> 不行。</p><p>对于 <code>T extends U ? X : Y</code>，如果 <code>T</code> 的类型是 <code>A | B | C</code>，则会被解析为 <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>。</p><h3 id=infer7><a href=https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types>infer</a></h3><p>在 <code>extends</code> 子语句中，可以使用 <code>infer</code> 进行类型推断，表示待推断的类型变量。这个变量可以在 <code>true</code> 分支中继续使用。</p><pre><code>type Flatten&lt;Type&gt; = Type extends Array&lt;infer Item&gt; ? Item : Type;
</code></pre><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>GetReturnType</span><span class=p>&lt;</span><span class=nt>Type</span><span class=p>&gt;</span> <span class=o>=</span> <span class=nx>Type</span> <span class=kr>extends</span> <span class=p>(...</span><span class=nx>args</span>: <span class=kt>never</span><span class=p>[])</span> <span class=o>=&gt;</span> <span class=k>infer</span> <span class=nx>Return</span>
</span></span><span class=line><span class=cl>  <span class=o>?</span> <span class=nx>Return</span>
</span></span><span class=line><span class=cl>  : <span class=kt>never</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>Num</span> <span class=o>=</span> <span class=nx>GetReturnType</span><span class=o>&lt;</span><span class=p>()</span> <span class=o>=&gt;</span> <span class=kt>number</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// type Num = number
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>Str</span> <span class=o>=</span> <span class=nx>GetReturnType</span><span class=o>&lt;</span><span class=p>(</span><span class=nx>x</span>: <span class=kt>string</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=kt>string</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// type Str = string
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>Bools</span> <span class=o>=</span> <span class=nx>GetReturnType</span><span class=o>&lt;</span><span class=p>(</span><span class=nx>a</span>: <span class=kt>boolean</span><span class=p>,</span> <span class=nx>b</span>: <span class=kt>boolean</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=kr>boolean</span><span class=p>[]</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>// type Bools = boolean[]
</span></span></span></code></pre></td></tr></table></div></div><p>好的，了解了以上操作符，也算入门了。快去尝试挑战吧。</p><h2 id=常见问题>常见问题</h2><p>在我解答的过程中，有一些比较有意思的知识点，在这里分别说说。</p><h3 id=t-extends-x-vs-t-extends-x><code>[T] extends [X]</code> vs <code>T extends X</code></h3><p>遇到这个问题是在 <a href=https://github.com/type-challenges/type-challenges/blob/main/questions/00296-medium-permutation/README.md>296・Permutation</a>，你可以先尝试解答。</p><p><code>T extends X</code> 我们都知道，但为啥会有 <code>[T] extends [X]</code>？下面来看两个例子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>ToArray</span><span class=p>&lt;</span><span class=nt>Type</span><span class=p>&gt;</span> <span class=o>=</span> <span class=nx>Type</span> <span class=kr>extends</span> <span class=kt>any</span> <span class=o>?</span> <span class=nx>Type</span><span class=p>[]</span> <span class=o>:</span> <span class=kt>never</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>StrArrOrNumArr</span> <span class=o>=</span> <span class=nx>ToArray</span><span class=p>&lt;</span><span class=nt>string</span> <span class=err>|</span> <span class=na>number</span><span class=p>&gt;;</span> <span class=c1>// type StrArrOrNumArr = string[] | number[]
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>ToArrayNonDist</span><span class=p>&lt;</span><span class=nt>Type</span><span class=p>&gt;</span> <span class=o>=</span> <span class=p>[</span><span class=nx>Type</span><span class=p>]</span> <span class=kr>extends</span> <span class=p>[</span><span class=kt>any</span><span class=p>]</span> <span class=o>?</span> <span class=nx>Type</span><span class=p>[]</span> <span class=o>:</span> <span class=kt>never</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>// &#39;StrArrOrNumArr&#39; is no longer a union.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>type</span> <span class=nx>StrArrOrNumArr</span> <span class=o>=</span> <span class=nx>ToArrayNonDist</span><span class=p>&lt;</span><span class=nt>string</span> <span class=err>|</span> <span class=na>number</span><span class=p>&gt;;</span> <span class=c1>// type StrArrOrNumArr = (string | number)[]
</span></span></span></code></pre></td></tr></table></div></div><p>简单的说，当 <code>T</code> 是联合类型的时候，会对其每个类型进行分配。由 <code>string | number</code> -> <code>ToArray&lt;string> | ToArray&lt;number></code> -> <code>string[] | number[]</code>。</p><p>如果要避免这种行为，则可以通过添加 <code>[]</code> 在 <code>extends</code> 关键字两侧来限制。更具体可以看<a href=https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types>文档解析</a>。</p><p>接下来再看两个例子，能够很好的证明上面的观点。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>ToBooleanArr</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;</span> <span class=o>=</span> <span class=nx>T</span> <span class=kr>extends</span> <span class=kr>boolean</span> <span class=o>?</span> <span class=nx>T</span><span class=p>[]</span> <span class=o>:</span> <span class=kt>never</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>BooleanArr</span> <span class=o>=</span> <span class=nx>ToBooleanArr</span><span class=p>&lt;</span><span class=nt>boolean</span><span class=p>&gt;</span> <span class=c1>// type BooleanArr = false[] | true[]
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>ToBooleanArr</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;</span> <span class=o>=</span> <span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=kr>extends</span> <span class=p>[</span><span class=kr>boolean</span><span class=p>]</span> <span class=o>?</span> <span class=nx>T</span><span class=p>[]</span> <span class=o>:</span> <span class=kt>never</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>BooleanArr</span> <span class=o>=</span> <span class=nx>ToBooleanArr</span><span class=p>&lt;</span><span class=nt>boolean</span><span class=p>&gt;</span> <span class=c1>// type BooleanArr = boolean[]
</span></span></span></code></pre></td></tr></table></div></div><p>看到这里你应该大概知道怎么回事了。接下来再看神奇的 <code>never</code> 判断。当我想要判断 <code>T</code> 是否是 <code>never</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>CheckNotNever</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;</span> <span class=o>=</span> <span class=nx>T</span> <span class=kr>extends</span> <span class=kt>never</span> <span class=o>?</span> <span class=kc>false</span> <span class=o>:</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>CheckString</span> <span class=o>=</span> <span class=nx>CheckNotNever</span><span class=p>&lt;</span><span class=nt>string</span><span class=p>&gt;</span> <span class=c1>// type CheckString = true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>type</span> <span class=nx>CheckNever</span> <span class=o>=</span> <span class=nx>CheckNotNever</span><span class=p>&lt;</span><span class=nt>never</span><span class=p>&gt;</span> <span class=c1>// type CheckNever = never
</span></span></span></code></pre></td></tr></table></div></div><p>咦，发现没有，当传 <code>never</code> 的时候，<code>CheckNever</code> 预期应该是 <code>false</code>，结果返回 <code>never</code>。Why？</p><p>我们再看一个测试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>UnionTypes</span> <span class=o>=</span> <span class=kt>string</span> <span class=o>|</span> <span class=kt>never</span> <span class=o>|</span> <span class=kt>number</span> <span class=c1>// type UnionTypes = string | number
</span></span></span></code></pre></td></tr></table></div></div><p><code>UnionTypes</code> 是不包含 <code>never</code> 的。所以通过上面两点，我们可以知道在 <code>T extends never</code> 时，如果 <code>T</code> 是 <code>never</code> ，则表示空联合。那么当然不会执行后面的条件。</p><p>所以要判断 <code>never</code>，我们只需要：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>CheckNotNever</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;</span> <span class=o>=</span> <span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=kr>extends</span> <span class=p>[</span><span class=kt>never</span><span class=p>]</span> <span class=o>?</span> <span class=kc>false</span> <span class=o>:</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>type</span> <span class=nx>CheckString</span> <span class=o>=</span> <span class=nx>CheckNotNever</span><span class=p>&lt;</span><span class=nt>string</span><span class=p>&gt;</span> <span class=c1>// type CheckString = true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>type</span> <span class=nx>CheckNever</span> <span class=o>=</span> <span class=nx>CheckNotNever</span><span class=p>&lt;</span><span class=nt>never</span><span class=p>&gt;</span> <span class=c1>// type CheckNever = false
</span></span></span></code></pre></td></tr></table></div></div><p>对于上面这个问题，这里有个很好的<a href=https://github.com/type-challenges/type-challenges/issues/614>解析</a>，建议围观。</p><h3 id=k-extends-k><code>K extends K</code></h3><p>这个判断会让人觉得很困惑，<code>K</code> 肯定是可以赋值给 <code>K</code> 的，那为啥还要判断？</p><p>其实上面也有解析，当 <code>K</code> 是联合类型的时候，会对每个类型进行分配，其结果会再联合。这其实可以理解为一个hack，以进行循环。</p><p>还是看这个<a href=https://github.com/type-challenges/type-challenges/issues/614>解析</a>，看完会有更全面的了解。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>type</span> <span class=nx>Permutation</span><span class=p>&lt;</span><span class=nt>T</span><span class=err>,</span> <span class=na>K</span><span class=o>=</span><span class=na>T</span><span class=p>&gt;</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=nx>T</span><span class=p>]</span> <span class=kr>extends</span> <span class=p>[</span><span class=kt>never</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=o>?</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>      <span class=o>:</span> <span class=nx>K</span> <span class=kr>extends</span> <span class=nx>K</span>
</span></span><span class=line><span class=cl>        <span class=o>?</span> <span class=p>[</span><span class=nx>K</span><span class=p>,</span> <span class=p>...</span><span class=nx>Permutation</span><span class=p>&lt;</span><span class=nt>Exclude</span><span class=err>&lt;</span><span class=na>T</span><span class=err>,</span> <span class=na>K</span><span class=p>&gt;</span><span class=o>&gt;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=kt>never</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=/post/2022/images/1011ts/iterate.png alt=iterate></p><h3 id=object-vs-object-vs-><code>Object</code> vs <code>object</code> vs <code>{}</code></h3><p>这三个类型是 <code>TS</code> 中让人比较困惑的存在，先看几个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kd>var</span> <span class=nx>o</span>: <span class=kt>object</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>o</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>prop</span>: <span class=kt>0</span> <span class=p>};</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>o</span> <span class=o>=</span> <span class=p>[];</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>o</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>o</span> <span class=o>=</span> <span class=s2>&#34;string&#34;</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>o</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>o</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>o</span> <span class=o>=</span> <span class=kc>undefined</span><span class=p>;</span> <span class=c1>// Error
</span></span></span></code></pre></td></tr></table></div></div><p><code>object</code> 是 <code>TS</code> 2.2 版本新增的一种类型：表示非基础类型。即不是
<code>number | string | boolean | symbol | null | undefined</code> 的类型。</p><p>下面看 <code>Object</code> 和 <code>{}</code>。这两个类型粗略一看一模一样啊，不是么？我们先看看 <code>Object</code> 的定义。</p><p>其中 <code>Object</code> 接口定义了 <code>Object.prototype</code> 原型对象上的属性。<code>ObjectConstructor</code> 接口定义了 <code>Object</code> 类的属性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>interface</span> <span class=nb>Object</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** The initial value of Object.prototype.constructor is the standard built-in Object constructor. */</span>
</span></span><span class=line><span class=cl>    <span class=kr>constructor</span><span class=o>:</span> <span class=nb>Function</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/** Returns a string representation of an object. */</span>
</span></span><span class=line><span class=cl>    <span class=nx>toString</span><span class=p>()</span><span class=o>:</span> <span class=kt>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/** Returns a date converted to a string using the current locale. */</span>
</span></span><span class=line><span class=cl>    <span class=nx>toLocaleString</span><span class=p>()</span><span class=o>:</span> <span class=kt>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/** Returns the primitive value of the specified object. */</span>
</span></span><span class=line><span class=cl>    <span class=nx>valueOf</span><span class=p>()</span><span class=o>:</span> <span class=nb>Object</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Determines whether an object has a property with the specified name.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param v A property name.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>hasOwnProperty</span><span class=p>(</span><span class=nx>v</span>: <span class=kt>PropertyKey</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Determines whether an object exists in another object&#39;s prototype chain.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param v Another object whose prototype chain is to be checked.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>isPrototypeOf</span><span class=p>(</span><span class=nx>v</span>: <span class=kt>Object</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Determines whether a specified property is enumerable.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param v A property name.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>propertyIsEnumerable</span><span class=p>(</span><span class=nx>v</span>: <span class=kt>PropertyKey</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>interface</span> <span class=nx>ObjectConstructor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span><span class=p>(</span><span class=nx>value?</span>: <span class=kt>any</span><span class=p>)</span><span class=o>:</span> <span class=nb>Object</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>()</span><span class=o>:</span> <span class=kt>any</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nx>value</span>: <span class=kt>any</span><span class=p>)</span><span class=o>:</span> <span class=kt>any</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/** A reference to the prototype for a class of objects. */</span>
</span></span><span class=line><span class=cl>    <span class=kr>readonly</span> <span class=nx>prototype</span>: <span class=kt>Object</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Returns the prototype of an object.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o The object that references the prototype.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>getPrototypeOf</span><span class=p>(</span><span class=nx>o</span>: <span class=kt>any</span><span class=p>)</span><span class=o>:</span> <span class=kt>any</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Gets the own property descriptor of the specified object.
</span></span></span><span class=line><span class=cl><span class=cm>     * An own property descriptor is one that is defined directly on the object and is not inherited from the object&#39;s prototype.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object that contains the property.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param p Name of the property.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>getOwnPropertyDescriptor</span><span class=p>(</span><span class=nx>o</span>: <span class=kt>any</span><span class=p>,</span> <span class=nx>p</span>: <span class=kt>PropertyKey</span><span class=p>)</span><span class=o>:</span> <span class=nx>PropertyDescriptor</span> <span class=o>|</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly
</span></span></span><span class=line><span class=cl><span class=cm>     * on that object, and are not inherited from the object&#39;s prototype. The properties of an object include both fields (objects) and functions.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object that contains the own properties.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>getOwnPropertyNames</span><span class=p>(</span><span class=nx>o</span>: <span class=kt>any</span><span class=p>)</span><span class=o>:</span> <span class=kt>string</span><span class=p>[];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Creates an object that has the specified prototype or that has null prototype.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object to use as a prototype. May be null.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>create</span><span class=p>(</span><span class=nx>o</span>: <span class=kt>object</span> <span class=o>|</span> <span class=kc>null</span><span class=p>)</span><span class=o>:</span> <span class=kt>any</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Creates an object that has the specified prototype, and that optionally contains specified properties.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object to use as a prototype. May be null
</span></span></span><span class=line><span class=cl><span class=cm>     * @param properties JavaScript object that contains one or more property descriptors.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>create</span><span class=p>(</span><span class=nx>o</span>: <span class=kt>object</span> <span class=o>|</span> <span class=kc>null</span><span class=p>,</span> <span class=nx>properties</span>: <span class=kt>PropertyDescriptorMap</span> <span class=o>&amp;</span> <span class=nx>ThisType</span><span class=p>&lt;</span><span class=nt>any</span><span class=p>&gt;)</span><span class=o>:</span> <span class=kt>any</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Adds a property to an object, or modifies attributes of an existing property.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param p The property name.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param attributes Descriptor for the property. It can be for a data property or an accessor property.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>defineProperty</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;(</span><span class=nx>o</span>: <span class=kt>T</span><span class=p>,</span> <span class=nx>p</span>: <span class=kt>PropertyKey</span><span class=p>,</span> <span class=nx>attributes</span>: <span class=kt>PropertyDescriptor</span> <span class=o>&amp;</span> <span class=nx>ThisType</span><span class=p>&lt;</span><span class=nt>any</span><span class=p>&gt;)</span><span class=o>:</span> <span class=nx>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Adds one or more properties to an object, and/or modifies attributes of existing properties.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object on which to add or modify the properties. This can be a native JavaScript object or a DOM object.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param properties JavaScript object that contains one or more descriptor objects. Each descriptor object describes a data property or an accessor property.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>defineProperties</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;(</span><span class=nx>o</span>: <span class=kt>T</span><span class=p>,</span> <span class=nx>properties</span>: <span class=kt>PropertyDescriptorMap</span> <span class=o>&amp;</span> <span class=nx>ThisType</span><span class=p>&lt;</span><span class=nt>any</span><span class=p>&gt;)</span><span class=o>:</span> <span class=nx>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Prevents the modification of attributes of existing properties, and prevents the addition of new properties.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object on which to lock the attributes.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>seal</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;(</span><span class=nx>o</span>: <span class=kt>T</span><span class=p>)</span><span class=o>:</span> <span class=nx>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param a Object on which to lock the attributes.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>freeze</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;(</span><span class=nx>a</span>: <span class=kt>T</span><span class=p>[])</span><span class=o>:</span> <span class=kr>readonly</span> <span class=nx>T</span><span class=p>[];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param f Object on which to lock the attributes.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>freeze</span><span class=p>&lt;</span><span class=nt>T</span> <span class=na>extends</span> <span class=na>Function</span><span class=p>&gt;(</span><span class=nx>f</span>: <span class=kt>T</span><span class=p>)</span><span class=o>:</span> <span class=nx>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object on which to lock the attributes.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>freeze</span><span class=p>&lt;</span><span class=nt>T</span> <span class=na>extends</span> <span class=p>{</span><span class=err>[</span><span class=na>idx</span><span class=err>:</span> <span class=na>string</span><span class=err>]:</span> <span class=na>U</span> <span class=err>|</span> <span class=na>null</span> <span class=err>|</span> <span class=na>undefined</span> <span class=err>|</span> <span class=na>object</span><span class=p>}</span><span class=err>,</span> <span class=na>U</span> <span class=na>extends</span> <span class=na>string</span> <span class=err>|</span> <span class=na>bigint</span> <span class=err>|</span> <span class=na>number</span> <span class=err>|</span> <span class=na>boolean</span> <span class=err>|</span> <span class=na>symbol</span><span class=p>&gt;(</span><span class=nx>o</span>: <span class=kt>T</span><span class=p>)</span><span class=o>:</span> <span class=nx>Readonly</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object on which to lock the attributes.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>freeze</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;(</span><span class=nx>o</span>: <span class=kt>T</span><span class=p>)</span><span class=o>:</span> <span class=nx>Readonly</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Prevents the addition of new properties to an object.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object to make non-extensible.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>preventExtensions</span><span class=p>&lt;</span><span class=nt>T</span><span class=p>&gt;(</span><span class=nx>o</span>: <span class=kt>T</span><span class=p>)</span><span class=o>:</span> <span class=nx>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Returns true if existing property attributes cannot be modified in an object and new properties cannot be added to the object.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object to test.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>isSealed</span><span class=p>(</span><span class=nx>o</span>: <span class=kt>any</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Returns true if existing property attributes and values cannot be modified in an object, and new properties cannot be added to the object.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object to test.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>isFrozen</span><span class=p>(</span><span class=nx>o</span>: <span class=kt>any</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Returns a value that indicates whether new properties can be added to an object.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object to test.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>isExtensible</span><span class=p>(</span><span class=nx>o</span>: <span class=kt>any</span><span class=p>)</span><span class=o>:</span> <span class=kr>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Returns the names of the enumerable string properties and methods of an object.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nx>keys</span><span class=p>(</span><span class=nx>o</span>: <span class=kt>object</span><span class=p>)</span><span class=o>:</span> <span class=kt>string</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Provides functionality common to all JavaScript objects.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kr>declare</span> <span class=kd>var</span> <span class=nb>Object</span><span class=o>:</span> <span class=nx>ObjectConstructor</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>由于 <code>js</code> 的自动装箱特性，所以基础类型也是可以赋值给 <code>Object</code> 和 <code>{}</code> 。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>p</span><span class=o>:</span> <span class=p>{};</span> <span class=c1>// or Object
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>p</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>prop</span>: <span class=kt>0</span> <span class=p>};</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>p</span> <span class=o>=</span> <span class=p>[];</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>p</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>p</span> <span class=o>=</span> <span class=s2>&#34;string&#34;</span><span class=p>;</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>p</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>p</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>p</span> <span class=o>=</span> <span class=kc>undefined</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>q</span><span class=o>:</span> <span class=p>{</span> <span class=p>[</span><span class=nx>key</span>: <span class=kt>string</span><span class=p>]</span><span class=o>:</span> <span class=kt>any</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>q</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>prop</span>: <span class=kt>0</span> <span class=p>};</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q</span> <span class=o>=</span> <span class=p>[];</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q</span> <span class=o>=</span> <span class=s2>&#34;string&#34;</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>q</span> <span class=o>=</span> <span class=kc>undefined</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>r</span><span class=o>:</span> <span class=p>{</span> <span class=p>[</span><span class=nx>key</span>: <span class=kt>string</span><span class=p>]</span><span class=o>:</span> <span class=kt>string</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=nx>r</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>prop</span><span class=o>:</span> <span class=s1>&#39;string&#39;</span> <span class=p>};</span> <span class=c1>// OK
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>r</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>prop</span>: <span class=kt>0</span> <span class=p>};</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>r</span> <span class=o>=</span> <span class=p>[];</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>r</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>r</span> <span class=o>=</span> <span class=s2>&#34;string&#34;</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>r</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>r</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span> <span class=c1>// Error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>r</span> <span class=o>=</span> <span class=kc>undefined</span><span class=p>;</span> <span class=c1>// Error
</span></span></span></code></pre></td></tr></table></div></div><p>由于 <code>Object</code> 是有原型方法的，如果实现其方法，则会进行对应校验。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>const</span> <span class=nx>obj1</span>: <span class=kt>Object</span> <span class=o>=</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>   <span class=nx>toString() {</span> <span class=k>return</span> <span class=mi>123</span> <span class=p>}</span> <span class=c1>// Error Type &#39;() =&gt; number&#39; is not assignable to type &#39;() =&gt; string&#39;. Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>但是 <code>{}</code> 则不一样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ts data-lang=ts><span class=line><span class=cl><span class=kr>const</span> <span class=nx>obj1</span><span class=o>:</span> <span class=p>{}</span> <span class=o>=</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>   <span class=nx>toString() {</span> <span class=k>return</span> <span class=mi>123</span> <span class=p>}</span> <span class=c1>// Success
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>结论：<code>Object</code> 是包含了 <code>toString</code>、<code>hasOwnProperty</code> 等方法的对象；<code>{}</code> 是空对象，但也能调用 <code>Object</code> 上的方法。可以说两者在运行时是没有差异的。但在编译时，<code>{}</code> 是不包含 <code>Object</code> 属性的，自然也不会进行校验。<code>Object</code> 则会进行对应校验，相比更加严格。</p><p>更加具体也可以查看 stackoverflow 上的这个<a href=https://stackoverflow.com/questions/49464634/difference-between-object-and-object-in-typescript>回答</a>。</p><h2 id=最后>最后</h2><p>综上，希望能对你们了解 <code>TS</code> 类型系统有所帮助。同时，我把我的 <code>type-challenges</code> 解答整理在<a href=https://github.com/cirplan/type-challenges-answer>这里</a>，有兴趣可以围观。</p><h2 id=参考>参考</h2><ul><li><a href=https://github.com/type-challenges/type-challenges>https://github.com/type-challenges/type-challenges</a></li><li><a href=https://www.typescriptlang.org/docs/handbook/intro.html>https://www.typescriptlang.org/docs/handbook/intro.html</a></li><li><a href=https://github.com/type-challenges/type-challenges/issues/614>https://github.com/type-challenges/type-challenges/issues/614</a></li><li><a href=https://stackoverflow.com/questions/49464634/difference-between-object-and-object-in-typescript>https://stackoverflow.com/questions/49464634/difference-between-object-and-object-in-typescript</a></li><li><a href=http://www.semlinker.com/ts-object-type/>http://www.semlinker.com/ts-object-type/</a></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/typescript/>typescript</a>
<a href=/tags/type/>type</a>
<a href=/tags/challenges/>challenges</a></div><nav class=post-nav><a class=prev href=/post/2022/11-22-mei-sha-jian-on-foot/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">记一次梅沙尖徒步</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/2022/10-10-ts-utility-types/><span class="next-text nav-default">TypeScript的内置类型</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=copyright><span class=copyright-year>&copy;
2013 -
2022<span class=heart>🥕</span><span>cirplan</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script>window.onload=function(){const e="fixed-open",n="slideout-open",s="icon-click",t=document.querySelector("#mobile-navbar-icon");t.addEventListener("click",o=>{const i=document.querySelector("#mobile-navbar"),a=document.querySelector("#mobile-panel");i.classList.contains(e)?(i.classList.remove(e),a.classList.remove(e),t.classList.remove(s),document.documentElement.classList.remove(n)):(i.classList.add(e),a.classList.add(e),t.classList.add(s),document.documentElement.classList.add(n))})}</script></body></html>